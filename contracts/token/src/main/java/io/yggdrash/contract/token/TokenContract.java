package io.yggdrash.contract.token;import java.math.BigInteger;import java.util.Hashtable;import java.util.Set;import com.google.gson.JsonArray;import com.google.gson.JsonObject;import io.yggdrash.common.contract.vo.PrefixKeyEnum;import io.yggdrash.common.crypto.HashUtil;import io.yggdrash.common.crypto.HexUtil;import io.yggdrash.common.store.BranchStateStore;import io.yggdrash.common.utils.ByteUtil;import io.yggdrash.common.utils.JsonUtil;import io.yggdrash.contract.core.ExecuteStatus;import io.yggdrash.contract.core.TransactionReceipt;import io.yggdrash.contract.core.annotation.ContractBranchStateStore;import io.yggdrash.contract.core.annotation.ContractChannelField;import io.yggdrash.contract.core.annotation.ContractChannelMethod;import io.yggdrash.contract.core.annotation.ContractQuery;import io.yggdrash.contract.core.annotation.ContractStateStore;import io.yggdrash.contract.core.annotation.ContractTransactionReceipt;import io.yggdrash.contract.core.annotation.Genesis;import io.yggdrash.contract.core.annotation.InvokeTransaction;import io.yggdrash.contract.core.channel.ContractChannel;import io.yggdrash.contract.core.channel.ContractMethodType;import io.yggdrash.contract.core.store.ReadWriterStore;import org.osgi.framework.BundleActivator;import org.osgi.framework.BundleContext;import org.osgi.framework.ServiceEvent;import org.osgi.framework.ServiceListener;import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class TokenContract implements BundleActivator, ServiceListener {    private static final String TOKEN_CONTRACT_NAME = "TOKEN";    private static final String TOKEN_PREFIX = "TOKEN-";    private static final String TOKEN_ID = "TOKEN_ID";    private static final String TOKEN_NAME = "TOKEN_NAME";    private static final String TOKEN_OWNER_ACCOUNT = "TOKEN_OWNER_ACCOUNT";    private static final String TOKEN_INIT_YEED_STAKE_AMOUNT = "TOKEN_INIT_YEED_STAKE_AMOUNT";    private static final String TOKEN_YEED_STAKE_AMOUNT = "TOKEN_YEED_STAKE_AMOUNT";    private static final String TOKEN_INIT_MINT_AMOUNT = "TOKEN_INIT_MINT_AMOUNT";    private static final String TOKEN_MINTABLE = "TOKEN_MINTABLE";    private static final String TOKEN_BURNABLE = "TOKEN_BURNABLE";    private static final String TOKEN_EXCHANGEABLE = "TOKEN_EXCHANGEABLE";    private static final String TOKEN_EX_TYPE = "TOKEN_EX_TYPE";    private static final String TOKEN_EX_TYPE_FIXED = "TOKEN_EX_TYPE_FIXED";    private static final String TOKEN_EX_TYPE_LINKED = "TOKEN_EX_TYPE_LINKED";    private static final String TOKEN_EX_RATE = "TOKEN_EX_RATE";    private static final String TOKEN_EX_OPEN_LIST = "TOKEN_EX_OPEN_LIST";    private static final String TOKEN_EX_TARGET_TOKEN_ID = "TOKEN_EX_TARGET_TOKEN_ID";    private static final String TOKEN_PHASE = "TOKEN_PHASE";    private static final String TOKEN_PHASE_INIT = "init";    private static final String TOKEN_PHASE_RUN = "run";    private static final String TOKEN_PHASE_PAUSE = "pause";    private static final String TOKEN_PHASE_STOP = "stop";    private static final String TOTAL_SUPPLY = "TOTAL_SUPPLY";    private static final String ADDRESS = "address";    private static final String AMOUNT = "amount";    private static final String BALANCE = "balance";    private static final String SPENDER = "spender";    private static final String OWNER = "owner";    private static final Logger log = LoggerFactory.getLogger(TokenContract.class);    @SuppressWarnings("RedundantThrows")    @Override    public void start(BundleContext context) throws Exception {        log.info("Start Token Contract");        Hashtable<String, String> props = new Hashtable<>();        props.put("YGGDRASH", "Token");        context.registerService(TokenService.class.getName(), new TokenService(), props);    }    @Override    public void stop(BundleContext context) {        log.info("Stop Token contract");    }    @Override    public void serviceChanged(ServiceEvent event) {        log.info("Token contract serviceChanged called");    }    // TODO : @kevin : 2019-08-22 : should apply tx fee to all token transactions    public static class TokenService {        @SuppressWarnings("WeakerAccess")        @ContractChannelField        public ContractChannel channel;        @ContractTransactionReceipt        TransactionReceipt txReceipt;        @ContractStateStore        ReadWriterStore<String, JsonObject> store;        @ContractBranchStateStore        BranchStateStore branchStateStore;        /**         * Genesis of CONTRACT not TOKEN         */        @Genesis        @InvokeTransaction        public TransactionReceipt init(JsonObject params) {            // TODO : @kevin : 2019-08-20 : check what to do            setSuccessTxReceipt("Token contract i18n completed successfully.");            return txReceipt;        }        /**         * @return Total amount of token in existence         */        @ContractQuery        public BigInteger totalSupply(JsonObject params) {            String tokenId = params.get(TOKEN_ID).getAsString().toLowerCase();            return getBalance(tokenId, TOTAL_SUPPLY);        }        @ContractQuery        public BigInteger balanceOf(JsonObject params) {            String tokenId = params.get(TOKEN_ID).getAsString().toLowerCase();            String address = params.get(ADDRESS).getAsString().toLowerCase();            return getBalance(tokenId, address);        }        @ContractQuery        @ContractChannelMethod        public BigInteger getYeedBalanceOf(JsonObject params) {            String tokenId = params.get(TOKEN_ID).getAsString().toLowerCase();            JsonObject token = loadTokenObject(tokenId);            return token.get(TOKEN_YEED_STAKE_AMOUNT).getAsBigInteger();        }        @ContractQuery        @ContractChannelMethod        public BigInteger getTokenBalanceOf(JsonObject params) {            String tokenId = params.get(TOKEN_ID).getAsString().toLowerCase();            String tokenAccountAddress = makeTokenAccountAddress(tokenId);            return getBalance(tokenId, tokenAccountAddress);        }        @ContractQuery        public BigInteger allowance(JsonObject params) {            String tokenId = params.get(TOKEN_ID).getAsString().toLowerCase();            String owner = params.get(OWNER).getAsString().toLowerCase();            String spender = params.get(SPENDER).getAsString().toLowerCase();            String approveKey = approveKey(owner, spender);            return getBalance(tokenId, approveKey);        }        @InvokeTransaction        public TransactionReceipt createToken(JsonObject params) {            JsonObject token = makeTokenObject(params);            String tokenId = token.get(TOKEN_ID).getAsString();            BigInteger totalSupply = token.get(TOKEN_INIT_MINT_AMOUNT).getAsBigInteger();            putBalance(tokenId, TOTAL_SUPPLY, totalSupply);            // STAKE            BigInteger stakeAmount = token.get(TOKEN_INIT_YEED_STAKE_AMOUNT).getAsBigInteger();            boolean isSuccess = depositYeedStake(txReceipt.getIssuer(), stakeAmount);            if (isSuccess == false) {                setErrorTxReceipt("Insufficient balance to stake!");                return txReceipt;            }            // create token success!            saveTokenObject(token);            setSuccessTxReceipt(                    String.format("Token [%s] creation completed successfully. Initial mint amount is %s.", tokenId, totalSupply));            return txReceipt;        }        @InvokeTransaction        public TransactionReceipt depositYeedStakeToToken(JsonObject params) {            String issuer = txReceipt.getIssuer();            String tokenId = params.get(TOKEN_ID).getAsString().toLowerCase();            JsonObject token = loadTokenObject(tokenId);            if (issuer.equals(token.get(TOKEN_OWNER_ACCOUNT).getAsString()) == false) {                setErrorTxReceipt("Issuer must be token owner!");                return txReceipt;            }            BigInteger amount = params.get(AMOUNT).getAsBigInteger();            boolean isSuccess = depositYeedStake(issuer, amount);            if (isSuccess == false) {                setErrorTxReceipt("Insufficient balance to deposit!");                return txReceipt;            }            BigInteger curStakeOfToken = token.get(TOKEN_YEED_STAKE_AMOUNT).getAsBigInteger();            token.addProperty(TOKEN_YEED_STAKE_AMOUNT, curStakeOfToken.add(amount));            saveTokenObject(token);            setSuccessTxReceipt(                    String.format("Token [%s] yeed stake deposit completed successfully. Amount is %s.", tokenId, amount));            return txReceipt;        }        @InvokeTransaction        public TransactionReceipt withdrawYeedStakeFromToken(JsonObject params) {            String issuer = txReceipt.getIssuer();            String tokenId = params.get(TOKEN_ID).getAsString().toLowerCase();            JsonObject token = loadTokenObject(tokenId);            if (issuer.equals(token.get(TOKEN_OWNER_ACCOUNT).getAsString()) == false) {                setErrorTxReceipt("Issuer must be token owner!");                return txReceipt;            }            BigInteger amount = params.get(AMOUNT).getAsBigInteger();            boolean isSuccess = withdrawYeedStake(issuer, amount);            if (isSuccess == false) {                setErrorTxReceipt("Insufficient balance to withdraw!");                return txReceipt;            }            BigInteger curStakeOfToken = token.get(TOKEN_YEED_STAKE_AMOUNT).getAsBigInteger();            token.addProperty(TOKEN_YEED_STAKE_AMOUNT, curStakeOfToken.subtract(amount));            saveTokenObject(token);            setSuccessTxReceipt(                    String.format("Token [%s] yeed stake withdrawal completed successfully. Amount is %s.", tokenId, amount));            return txReceipt;        }        @InvokeTransaction        public TransactionReceipt movePhaseRun(JsonObject params) {            String issuer = txReceipt.getIssuer();            String tokenId = params.get(TOKEN_ID).getAsString().toLowerCase();            JsonObject token = loadTokenObject(tokenId);            if (issuer.equals(token.get(TOKEN_OWNER_ACCOUNT).getAsString()) == false) {                setErrorTxReceipt("Issuer must be token owner!");                return txReceipt;            }            String phase = token.get(TOKEN_PHASE).getAsString();            if ((TOKEN_PHASE_INIT.equals(phase) || TOKEN_PHASE_PAUSE.equals(phase)) == false) {                setErrorTxReceipt("If you want to move token phase to RUN, current token phase must be INIT or PAUSE!");                return txReceipt;            }            token.addProperty(TOKEN_PHASE, TOKEN_PHASE_RUN);            saveTokenObject(token);            setSuccessTxReceipt("Token phase was moved to RUN!");            return txReceipt;        }        @InvokeTransaction        public TransactionReceipt movePhasePause(JsonObject params) {            String issuer = txReceipt.getIssuer();            String tokenId = params.get(TOKEN_ID).getAsString().toLowerCase();            JsonObject token = loadTokenObject(tokenId);            if (issuer.equals(token.get(TOKEN_OWNER_ACCOUNT).getAsString()) == false) {                setErrorTxReceipt("Issuer must be token owner!");                return txReceipt;            }            String phase = token.get(TOKEN_PHASE).getAsString();            if (TOKEN_PHASE_RUN.equals(phase) == false) {                setErrorTxReceipt("If you want to move token phase to PAUSE, current token phase must be RUN!");                return txReceipt;            }            token.addProperty(TOKEN_PHASE, TOKEN_PHASE_PAUSE);            saveTokenObject(token);            setSuccessTxReceipt("Token phase was moved to PAUSE!");            return txReceipt;        }        @InvokeTransaction        public TransactionReceipt movePhaseStop(JsonObject params) {            String issuer = txReceipt.getIssuer();            String tokenId = params.get(TOKEN_ID).getAsString().toLowerCase();            JsonObject token = loadTokenObject(tokenId);            if (issuer.equals(token.get(TOKEN_OWNER_ACCOUNT).getAsString()) == false) {                setErrorTxReceipt("Issuer must be token owner!");                return txReceipt;            }            String phase = token.get(TOKEN_PHASE).getAsString();            if ((TOKEN_PHASE_RUN.equals(phase) || TOKEN_PHASE_PAUSE.equals(phase)) == false) {                setErrorTxReceipt("If you want to move token phase to STOP, current token phase must be RUN or PAUSE!");                return txReceipt;            }            token.addProperty(TOKEN_PHASE, TOKEN_PHASE_STOP);            saveTokenObject(token);            setSuccessTxReceipt("Token phase was moved to STOP!");            return txReceipt;        }        // TODO : @kevin : 2019-08-20 : should check destroy needed        @InvokeTransaction        public TransactionReceipt destroyToken(JsonObject params) {            // issuer 가 토큰 오너인가            // 현재 상태가 stop 인가            return null;        }        @InvokeTransaction        public TransactionReceipt transfer(JsonObject params) {            String tokenId = params.get(TOKEN_ID).getAsString().toLowerCase();            if (isTokenRunning(tokenId) == false) {                setErrorTxReceipt("Token is not running!");                return txReceipt;            }            String from = txReceipt.getIssuer();            BigInteger fromBalance = getBalance(tokenId, from);            BigInteger transferAmount = params.get(AMOUNT).getAsBigInteger();            if (transferAmount.compareTo(BigInteger.ZERO) <= 0) {                setErrorTxReceipt("Transfer amount must be greater than ZERO!");                return txReceipt;            }            if (fromBalance.compareTo(transferAmount) < 0) {                setErrorTxReceipt("Insufficient balance to transfer!");                return txReceipt;            }            // TODO : @kevin : 2019-08-20 : should pay YEED fee from stake            String to = params.get("to").getAsString().toLowerCase();            BigInteger newFromBalance = getBalance(tokenId, from).subtract(transferAmount);            BigInteger newToBalance = getBalance(tokenId, to).add(transferAmount);            putBalance(tokenId, from, newFromBalance);            putBalance(tokenId, to, newToBalance);            setSuccessTxReceipt(                    String.format("[Token Transferred] Token [%s] transfer %s from %s to %s.", tokenId, transferAmount, from, to));            return txReceipt;        }        @InvokeTransaction        public TransactionReceipt approve(JsonObject params) {            String tokenId = params.get(TOKEN_ID).getAsString().toLowerCase();            if (isTokenRunning(tokenId) == false) {                setErrorTxReceipt("Token is not running!");                return txReceipt;            }            String sender = txReceipt.getIssuer();            BigInteger approveAmount = params.get(AMOUNT).getAsBigInteger();            BigInteger senderBalance = getBalance(tokenId, sender);            if (senderBalance.compareTo(approveAmount) < 0) {                setErrorTxReceipt("Insufficient balance to approve!");                return txReceipt;            }            String spender = params.get(SPENDER).getAsString().toLowerCase();            String approveKey = approveKey(sender, spender);            putBalance(tokenId, approveKey, approveAmount);            setSuccessTxReceipt(                    String.format("[Token Approved] Token [%s] approve %s to %s from %s.", tokenId, spender, approveAmount, sender));            return txReceipt;        }        @InvokeTransaction        public TransactionReceipt transferFrom(JsonObject params) {            String tokenId = params.get(TOKEN_ID).getAsString().toLowerCase();            if (isTokenRunning(tokenId) == false) {                setErrorTxReceipt("Token is not running!");                return txReceipt;            }            String from = params.get("from").getAsString().toLowerCase();            String to = params.get("to").getAsString().toLowerCase();            BigInteger transferAmount = params.get(AMOUNT).getAsBigInteger();            if (transferAmount.compareTo(BigInteger.ZERO) <= 0) {                setErrorTxReceipt("Transfer amount must be greater than ZERO!");                return txReceipt;            }            String sender = txReceipt.getIssuer();            String approveKey = approveKey(from, sender);            BigInteger approveBalance = getBalance(tokenId, approveKey);            if (transferAmount.compareTo(approveBalance) > 0) {                setErrorTxReceipt("Insufficient approved balance to transferFrom!");                return txReceipt;            }            BigInteger newApproveBalance = getBalance(tokenId, approveKey).subtract(transferAmount);            BigInteger newToBalance = getBalance(tokenId, to).add(transferAmount);            putBalance(tokenId, approveKey, newApproveBalance);            putBalance(tokenId, to, newToBalance);            setSuccessTxReceipt(                    String.format("[Token TransferredFrom] Token [%s] transferred %s from %s to %s by %s.", tokenId, transferAmount, from, to, from));            return txReceipt;        }        @InvokeTransaction        public TransactionReceipt mint(JsonObject params) {            String issuer = txReceipt.getIssuer();            String tokenId = params.get(TOKEN_ID).getAsString().toLowerCase();            JsonObject token = loadTokenObject(tokenId);            if (issuer.equals(token.get(TOKEN_OWNER_ACCOUNT).getAsString()) == false) {                setErrorTxReceipt("Issuer must be token owner!");                return txReceipt;            }            boolean mintable = token.get(TOKEN_MINTABLE).getAsBoolean();            if (mintable == false) {                setErrorTxReceipt("Token is not mintable!");                return txReceipt;            }            String tokenOwnerAccount = token.get(TOKEN_OWNER_ACCOUNT).getAsString();            BigInteger mintAmount = params.get(AMOUNT).getAsBigInteger();            if (mintAmount.compareTo(BigInteger.ZERO) <= 0) {                setErrorTxReceipt("Mint amount must be greater than ZERO!");                return txReceipt;            }            BigInteger tokenOwnerAccountBalance = getBalance(tokenId, tokenOwnerAccount);            BigInteger newTokenOwnerAccountBalance = tokenOwnerAccountBalance.add(mintAmount);            putBalance(tokenId, tokenOwnerAccount, newTokenOwnerAccountBalance);            BigInteger totalSupply = getBalance(tokenId, TOTAL_SUPPLY);            putBalance(tokenId, TOTAL_SUPPLY, totalSupply.add(mintAmount));            setSuccessTxReceipt(                    String.format("[Token Minted] Token [%s] minted %s.", tokenId, mintAmount));            return txReceipt;        }        @InvokeTransaction        public TransactionReceipt burn(JsonObject params) {            String issuer = txReceipt.getIssuer();            String tokenId = params.get(TOKEN_ID).getAsString().toLowerCase();            JsonObject token = loadTokenObject(tokenId);            if (issuer.equals(token.get(TOKEN_OWNER_ACCOUNT).getAsString()) == false) {                setErrorTxReceipt("Issuer must be token owner!");                return txReceipt;            }            boolean burnable = token.get(TOKEN_BURNABLE).getAsBoolean();            if (burnable == false) {                setErrorTxReceipt("Token is not burnable!");                return txReceipt;            }            String tokenOwnerAccount = token.get(TOKEN_OWNER_ACCOUNT).getAsString();            BigInteger burnAmount = params.get(AMOUNT).getAsBigInteger();            if (burnAmount.compareTo(BigInteger.ZERO) <= 0) {                setErrorTxReceipt("Burn amount must be greater than ZERO!");                return txReceipt;            }            BigInteger tokenOwnerAccountBalance = getBalance(tokenId, tokenOwnerAccount);            if (tokenOwnerAccountBalance.compareTo(burnAmount) < 0) {                setErrorTxReceipt("Insufficient token owner balance to burn!");                return txReceipt;            }            BigInteger newTokenOwnerAccountBalance = tokenOwnerAccountBalance.subtract(burnAmount);            putBalance(tokenId, tokenOwnerAccount, newTokenOwnerAccountBalance);            BigInteger totalSupply = getBalance(tokenId, TOTAL_SUPPLY);            putBalance(tokenId, TOTAL_SUPPLY, totalSupply.subtract(burnAmount));            setSuccessTxReceipt(                    String.format("[Token Burned] Token [%s] burned %s.", tokenId, burnAmount));            return txReceipt;        }        @InvokeTransaction        public TransactionReceipt openExchange(JsonObject params) {            String tokenId = params.get(TOKEN_ID).getAsString().toLowerCase();            String targetTokenId = params.get(TOKEN_EX_TARGET_TOKEN_ID).getAsString().toLowerCase();            if (isExchangeOpen(tokenId, targetTokenId)) {                setErrorTxReceipt("Target token is already open!");                return txReceipt;            }            JsonObject token = loadTokenObject(tokenId);            JsonArray curOpenList = token.get(TOKEN_EX_OPEN_LIST).getAsJsonArray();            curOpenList.add(targetTokenId);            token.add(TOKEN_EX_OPEN_LIST, curOpenList);            saveTokenObject(token);            setSuccessTxReceipt(                    String.format("Token [%s] exchange open to target token %s completed successfully.", tokenId, targetTokenId));            return txReceipt;        }        @InvokeTransaction        public TransactionReceipt closeExchange(JsonObject params) {            String tokenId = params.get(TOKEN_ID).getAsString().toLowerCase();            String targetTokenId = params.get(TOKEN_EX_TARGET_TOKEN_ID).getAsString().toLowerCase();            if (isExchangeOpen(tokenId, targetTokenId) == false) {                setErrorTxReceipt("Target token is already closed!");                return txReceipt;            }            JsonObject token = loadTokenObject(tokenId);            JsonArray curOpenList = token.get(TOKEN_EX_OPEN_LIST).getAsJsonArray();            for (int i = 0; i < curOpenList.size(); i++) {                if (targetTokenId.equals(curOpenList.get(i).getAsString())) {                    curOpenList.remove(i);                    break;                }            }            token.add(TOKEN_EX_OPEN_LIST, curOpenList);            saveTokenObject(token);            setSuccessTxReceipt(                    String.format("Token [%s] exchange close to target token %s completed successfully.", tokenId, targetTokenId));            return txReceipt;        }        @InvokeTransaction        public TransactionReceipt exchangeT2Y(JsonObject params) {            String tokenId = params.get(TOKEN_ID).getAsString().toLowerCase();            if (isTokenRunning(tokenId) == false) {                setErrorTxReceipt("Token is not running!");                return txReceipt;            }            JsonObject token = loadTokenObject(tokenId);            boolean exchangeable = token.get(TOKEN_EXCHANGEABLE).getAsBoolean();            if (exchangeable == false) {                setErrorTxReceipt("Token is not exchangeable!");                return txReceipt;            }            String issuer = txReceipt.getIssuer();            BigInteger issuerTokenBalance = getBalance(tokenId, issuer);            BigInteger tokenAmount = params.get(AMOUNT).getAsBigInteger();            if (tokenAmount.compareTo(BigInteger.ZERO) <= 0) {                setErrorTxReceipt("Exchange amount must be greater than ZERO!");                return txReceipt;            }            if (issuerTokenBalance.compareTo(tokenAmount) < 0) {                setErrorTxReceipt("Insufficient balance to exchange!");                return txReceipt;            }            String exType = token.get(TOKEN_EX_TYPE).getAsString();            BigInteger yeedAmount = BigInteger.ZERO;            switch (exType) {                case TOKEN_EX_TYPE_FIXED :                    double exRate = token.get(TOKEN_EX_RATE).getAsDouble();                    long yeedAmountL = (long)((double)(tokenAmount.longValue()) / exRate);                    yeedAmount = BigInteger.valueOf(yeedAmountL);                    BigInteger yeedStakeAmountOfToken = token.get(TOKEN_YEED_STAKE_AMOUNT).getAsBigInteger();                    if (yeedStakeAmountOfToken.compareTo(yeedAmount) < 0) {                        setErrorTxReceipt("Insufficient yeed stake amount of the token to withdraw!");                        return txReceipt;                    }                    boolean isWithdrawalSuccess = withdrawYeedStake(issuer, yeedAmount);                    if (isWithdrawalSuccess == false) {                        setErrorTxReceipt("Insufficient yeed stake amount of the contract to withdraw!");                        return txReceipt;                    }                    BigInteger curYeedStakeOfToken = token.get(TOKEN_YEED_STAKE_AMOUNT).getAsBigInteger();                    token.addProperty(TOKEN_YEED_STAKE_AMOUNT, curYeedStakeOfToken.subtract(yeedAmount));                    saveTokenObject(token);                    BigInteger curTokenBalance = getBalance(tokenId, issuer);                    putBalance(tokenId, issuer, curTokenBalance.subtract(tokenAmount));                    BigInteger curTotalSupplyOfToken = getBalance(tokenId, TOTAL_SUPPLY);                    putBalance(tokenId, TOTAL_SUPPLY, curTotalSupplyOfToken.subtract(tokenAmount));                    break;                case TOKEN_EX_TYPE_LINKED :                    // TODO : @kevin : 2019-08-22 : should implement linked case                    break;                default :                    break;            }            setSuccessTxReceipt(                    String.format("Token [%s] was exchanged to YEED successfully. Token %s was exchanged to YEED %s.", tokenId, tokenAmount, yeedAmount));            return txReceipt;        }        @InvokeTransaction        public TransactionReceipt exchangeY2T(JsonObject params) {            String tokenId = params.get(TOKEN_ID).getAsString().toLowerCase();            if (isTokenRunning(tokenId) == false) {                setErrorTxReceipt("Token is not running!");                return txReceipt;            }            JsonObject token = loadTokenObject(tokenId);            boolean exchangeable = token.get(TOKEN_EXCHANGEABLE).getAsBoolean();            if (exchangeable == false) {                setErrorTxReceipt("Token is not exchangeable!");                return txReceipt;            }            String issuer = txReceipt.getIssuer();            BigInteger yeedAmount = params.get(AMOUNT).getAsBigInteger();            if (yeedAmount.compareTo(BigInteger.ZERO) <= 0) {                setErrorTxReceipt("Exchange amount must be greater than ZERO!");                return txReceipt;            }            String exType = token.get(TOKEN_EX_TYPE).getAsString();            BigInteger tokenAmount = BigInteger.ZERO;            switch (exType) {                case TOKEN_EX_TYPE_FIXED:                    boolean isDepositSuccess = depositYeedStake(issuer, yeedAmount);                    if (isDepositSuccess == false) {                        setErrorTxReceipt("Insufficient yeed balance to deposit!");                        return txReceipt;                    }                    BigInteger curYeedStakeOfToken = token.get(TOKEN_YEED_STAKE_AMOUNT).getAsBigInteger();                    token.addProperty(TOKEN_YEED_STAKE_AMOUNT, curYeedStakeOfToken.add(yeedAmount));                    saveTokenObject(token);                    double exRate = token.get(TOKEN_EX_RATE).getAsDouble();                    long tokenAmountL = (long)((double)(yeedAmount.longValue()) * exRate);                    tokenAmount = BigInteger.valueOf(tokenAmountL);                    BigInteger curTokenBalance = getBalance(tokenId, issuer);                    putBalance(tokenId, issuer, curTokenBalance.add(tokenAmount));                    BigInteger curTokenTotalSupply = getBalance(tokenId, TOTAL_SUPPLY);                    putBalance(tokenId, TOTAL_SUPPLY, curTokenTotalSupply.add(tokenAmount));                    break;                case TOKEN_EX_TYPE_LINKED :                    // TODO : @kevin : 2019-08-22 : should implement linked case                    break;                default :                    break;            }            setSuccessTxReceipt(                    String.format("Token [%s] was exchanged from YEED successfully. YEED %s was exchanged to token %s.", tokenId, yeedAmount, tokenAmount));            return txReceipt;        }        @InvokeTransaction        public TransactionReceipt exchangeT2T(JsonObject params) {            String tokenId = params.get(TOKEN_ID).getAsString().toLowerCase();            if (isTokenRunning(tokenId) == false) {                setErrorTxReceipt("Token is not running!");                return txReceipt;            }            JsonObject token = loadTokenObject(tokenId);            boolean exchangeable = token.get(TOKEN_EXCHANGEABLE).getAsBoolean();            if (exchangeable == false) {                setErrorTxReceipt("Token is not exchangeable!");                return txReceipt;            }            String targetTokenId = params.get(TOKEN_EX_TARGET_TOKEN_ID).getAsString();            if (isExchangeOpen(tokenId, targetTokenId) == false) {                setErrorTxReceipt("Token exchange is not opened to target token!");                return txReceipt;            }            String issuer = txReceipt.getIssuer();            BigInteger issuerTokenBalance = getBalance(tokenId, issuer);            BigInteger tokenAmount = params.get(AMOUNT).getAsBigInteger();            if (tokenAmount.compareTo(BigInteger.ZERO) <= 0) {                setErrorTxReceipt("Exchange amount must be greater than ZERO!");                return txReceipt;            }            if (issuerTokenBalance.compareTo(tokenAmount) < 0) {                setErrorTxReceipt("Insufficient balance to exchange!");                return txReceipt;            }            String exType = token.get(TOKEN_EX_TYPE).getAsString();            long yeedAmountL = 0L;            switch (exType) {                case TOKEN_EX_TYPE_FIXED:                    double tokenExRate = token.get(TOKEN_EX_RATE).getAsDouble();                    yeedAmountL = (long)((double)(tokenAmount.longValue()) / tokenExRate);                    break;                case TOKEN_EX_TYPE_LINKED:                    // TODO : @kevin : 2019-08-22 : should implement linked case                    break;                default:                    break;            }            JsonObject targetToken = loadTokenObject(targetTokenId);            String targetExType = targetToken.get(TOKEN_EX_TYPE).getAsString();            BigInteger targetTokenAmount = BigInteger.ZERO;            switch (targetExType) {                case TOKEN_EX_TYPE_FIXED:                    double targetTokenExRate = targetToken.get(TOKEN_EX_RATE).getAsDouble();                    long targetTokenAmountL = (long)((double)(yeedAmountL) * targetTokenExRate);                    targetTokenAmount = BigInteger.valueOf(targetTokenAmountL);                    break;                case TOKEN_EX_TYPE_LINKED:                    // TODO : @kevin : 2019-08-22 : should implement linked case                    break;                default:                    break;            }            BigInteger curTokenBalance = getBalance(tokenId, issuer);            putBalance(tokenId, issuer, curTokenBalance.subtract(tokenAmount));            BigInteger curTotalSupplyOfToken = getBalance(tokenId, TOTAL_SUPPLY);            putBalance(tokenId, TOTAL_SUPPLY, curTotalSupplyOfToken.subtract(tokenAmount));            BigInteger curTargetTokenBalance = getBalance(targetTokenId, issuer);            putBalance(targetTokenId, issuer, curTargetTokenBalance.add(targetTokenAmount));            BigInteger curTargetTokenTotalSupply = getBalance(targetTokenId, TOTAL_SUPPLY);            putBalance(targetTokenId, TOTAL_SUPPLY, curTargetTokenTotalSupply.add(targetTokenAmount));            setSuccessTxReceipt(                    String.format("Token [%s] was exchanged to target token %s successfully. Token %s was exchanged to target token %s.", tokenId, targetTokenId, tokenAmount, targetTokenAmount));            return txReceipt;        }        private BigInteger getBalance(String tokenId, String address) {            String targetAddress =                    PrefixKeyEnum.ACCOUNT.toValue().concat(getTokenAddress(tokenId, address));            JsonObject storeValue = store.get(targetAddress);            return storeValue != null && storeValue.has(BALANCE)                    ? storeValue.get(BALANCE).getAsBigInteger() : BigInteger.ZERO;        }        private void putBalance(String tokenId, String address, BigInteger value) {            String targetAddress =                    PrefixKeyEnum.ACCOUNT.toValue().concat(getTokenAddress(tokenId, address));            JsonObject storeValue = new JsonObject();            storeValue.addProperty(BALANCE, value);            store.put(targetAddress, storeValue);        }        private String approveKey(String sender, String spender) {            byte[] approveKeyByteArray = ByteUtil.merge(sender.getBytes(), spender.getBytes());            byte[] approveKey = HashUtil.sha3(approveKeyByteArray);            return PrefixKeyEnum.APPROVE.toValue().concat(HexUtil.toHexString(approveKey));        }        private void setErrorTxReceipt(String msg) {            this.txReceipt.setStatus(ExecuteStatus.ERROR);            this.txReceipt.addLog(msg);        }        private void setSuccessTxReceipt(String msg) {            this.txReceipt.setStatus(ExecuteStatus.SUCCESS);            this.txReceipt.addLog(msg);        }        private JsonObject makeTokenObject(JsonObject params) {            JsonObject token = new JsonObject();            token.addProperty(TOKEN_ID, params.get(TOKEN_ID).getAsString().toLowerCase());            token.addProperty(TOKEN_NAME, params.get(TOKEN_NAME).getAsString());            token.addProperty(TOKEN_INIT_YEED_STAKE_AMOUNT, params.get(TOKEN_INIT_YEED_STAKE_AMOUNT).getAsBigInteger());            token.addProperty(TOKEN_YEED_STAKE_AMOUNT, params.get(TOKEN_INIT_YEED_STAKE_AMOUNT).getAsBigInteger());            // TODO : @kevin : 2019-08-20 : check owner account == create token issuer            token.addProperty(TOKEN_OWNER_ACCOUNT, txReceipt.getIssuer());            token.addProperty(TOKEN_INIT_MINT_AMOUNT, params.get(TOKEN_INIT_MINT_AMOUNT).getAsBigInteger());            token.addProperty(TOKEN_MINTABLE, params.get(TOKEN_MINTABLE).getAsBoolean());            token.addProperty(TOKEN_BURNABLE, params.get(TOKEN_BURNABLE).getAsBoolean());            token.addProperty(TOKEN_EXCHANGEABLE, params.get(TOKEN_EXCHANGEABLE).getAsBoolean());            token.addProperty(TOKEN_EX_TYPE, params.get(TOKEN_EX_TYPE).getAsString());            token.addProperty(TOKEN_EX_RATE, params.get(TOKEN_EX_RATE).getAsDouble());            token.add(TOKEN_EX_OPEN_LIST, new JsonArray());            token.addProperty(TOKEN_PHASE, TOKEN_PHASE_INIT);            return token;        }        private void saveTokenObject(JsonObject token) {            String tokenId = token.get(TOKEN_ID).getAsString();            store.put(TOKEN_PREFIX.concat(tokenId), token);        }        private JsonObject loadTokenObject(String tokenId) {            return store.get(TOKEN_PREFIX.concat(tokenId));        }        private String getTokenAddress(String tokenId, String address) {            return tokenId.concat("-").concat(address);        }        private String makeTokenAccountAddress(String tokenId) {            // TODO : @kevin : 2019-08-16 : should define the format of tokenAccountAddress            return tokenId;        }        private boolean depositYeedStake(String from, BigInteger amount) {            String issuer = txReceipt.getIssuer();            String methodName = issuer.equals(from) ? "transferChannel" : "transferFromChannel";            JsonObject param = new JsonObject();            param.addProperty("from", from);            param.addProperty("to", TOKEN_CONTRACT_NAME);            param.addProperty("amount", amount);            String yeedContractVersion = this.branchStateStore.getContractVersion("YEED");            log.debug("YEED Contract {}", yeedContractVersion);            JsonObject result = this.channel.call(                    yeedContractVersion, ContractMethodType.CHANNEL_METHOD, methodName, param);            return result.get("result").getAsBoolean();        }        private boolean withdrawYeedStake(String to, BigInteger amount) {            JsonObject param = new JsonObject();            param.addProperty("from", TOKEN_CONTRACT_NAME);            param.addProperty("to", to);            param.addProperty("amount", amount);            String yeedContractVersion = this.branchStateStore.getContractVersion("YEED");            log.debug("YEED Contract {}", yeedContractVersion);            JsonObject result = this.channel.call(                    yeedContractVersion, ContractMethodType.CHANNEL_METHOD, "transferChannel", param);            return result.get("result").getAsBoolean();        }        private boolean isTokenRunning(String tokenId) {            return TOKEN_PHASE_RUN.equals(loadTokenObject(tokenId).get(TOKEN_PHASE).getAsString());        }        private boolean isExchangeOpen(String tokenId, String targetTokenId) {            JsonObject token = loadTokenObject(tokenId);            JsonArray openArray = token.get(TOKEN_EX_OPEN_LIST).getAsJsonArray();            Set<String> openSet = JsonUtil.convertJsonArrayToSet(openArray);            return openSet.contains(targetTokenId);        }    }}