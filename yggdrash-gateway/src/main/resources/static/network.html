<!--
  ~ Copyright 2018 Akashic Foundation
  ~ Licensed under the Apache License, Version 2.0 (the “License”);
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an “AS IS” BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License
  -->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <script src="http://d3js.org/d3.v2.min.js?2.9.3"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <title>Network Graph</title>
</head>
<style>
    .link {
        stroke: #aaa;
    }

    .node text {
        stroke: #333;
        cursos: pointer;
    }

    .node circle {
        stroke: #fff;
        stroke-width: 3px;
        fill: #d46979;
    }

    #drawNetwork {
        height: 50px;
        width: 150px;
        background-color: aquamarine;
        font-size: larger;
        margin-top: 0%;
    }
</style>
<body onload="pageLoaded()">
<button id="drawNetwork">Draw Network</button>
<script>
    var curBlockHeight = 0;
    var grpc = 32918;
    var rest = 8080;
    var branchId = "91b29a1453258d72ca6fbbcabb8dca10cca944fb";
    var groups = ["91b29a1453258d72ca6fbbcabb8dca10cca944fb", "d872b5a338b824dc56abc6015543496670d81c1b"]; //todo later

    // data format
    var nodes = [];
    var links = [];
    var graphFile = {
        "nodes": nodes,
        "links": links
    };

    var channels = [];
    var stack = [];
    var table = [];

    function setUp(ip, branchId) {

        setNodesAndChannels(ip, branchId);
        setBlockHeight(ip, branchId);
    }

    function setNodesAndChannels(ip, branchId) {
        var url = getBucketsReqUrl(ip, branchId);

        $.getJSON(url).done(function (allPeers) {
            console.log("setNodesAndChannels :: allPeers => ", allPeers);

            allPeers.forEach(function (grpcUrl) {
                nodes.push(grpcUrl);
                channels.push(getChannelsReqUrl(getRestUrl(grpcUrl), branchId));
            });
        });
    }

    function setBlockHeight(host, port, branchId) {
        var url = getLatestBlockReqUrl(host, port, branchId);

        $.getJSON(url).done(function (latestBlock) {
            curBlockHeight = latestBlock.index;
            console.log("curBlockHeight=> ", curBlockHeight);
        });
    }

    function pageLoaded() {
        var url = document.URL;
        var host = getHost(url);
        var port = getPort(url);
        var pAt = url.indexOf("&");
        if (pAt > 0 && url.substr(pAt + 1) !== "") {
            branchId = url.substr(pAt + 1);
        }
        var ip = host + ":" + port;
        setUp(ip, branchId);
    }

    function getHost(str) {
        if (str.length < 20) {
            return str.substr(0, str.indexOf(":"));
        }
        return str.substr(7, str.lastIndexOf(":") - 7);
    }

    function getPort(str) {
        if (str.length < 20) {
            return str.substr(str.lastIndexOf(":") + 1, 5);
        }
        return str.substr(str.lastIndexOf(":") + 1, 4);
    }

    function getBucketsReqUrl(ip, branchId) {
        return "http://" + ip + "/peers/" + branchId + "/buckets";
    }

    function getChannelsReqUrl(ip, branchId) {
        return "http://" + ip + "/peers/" + branchId + "/channels";
    }

    function getLatestBlockReqUrl(ip, branchId) {
        return "http://" + ip + "/branches/" + branchId + "/blocks/latest";
    }

    function getGrpcUrl(str) { //Convert rest to grpc url
        return getHost(str) + ":" + getGrpcPort(str);
    }

    function getGrpcPort(str) {
        return grpc + (parseInt(getPort(str)) - rest);
    }

    function getRestUrl(str) { //Convert grpc to rest url
        return getHost(str) + ":" + getRestPort(str);
    }

    function getRestPort(str) {
        return rest + (parseInt(getPort(str)) - grpc);
    }

    function submit(curChannels) {
        stack.push(curChannels);
        console.log("curChannels => " + curChannels);

        $.getJSON(curChannels).done(function (activePeerList) {
            console.log("activePeerList", activePeerList);

            var key;
            var values = [];
            var row = {"key": key, "value": values};
            row.key = getGrpcUrl(curChannels);
            row.value = activePeerList;
            table.push(row);

            while (channels.length !== 0) {
                submit(channels.pop());
            }
        });
    }

    function arrangeTable() {
        table.forEach(function (row) {
            console.log("peer : " + row.key + ", number of connection : " + row.value.length);
            if (!nodes.includes(row.key)) {
                nodes.push(row.key);
            }
        });

        table.forEach(function (row) {
            row.value.forEach(function (value) {
                if (!nodes.includes(value)) {
                    nodes.push(value);
                }
            })
        });

        nodes.forEach(function (name, i) {
            nodes[i] = {"name": name, "group": 0};
        });
        console.log("ArrangeTable :: nodes => ", nodes);

        table.forEach(function (row) {
            var src = 0;

            nodes.forEach(function (value, index) {
                if (value.name === row.key) {
                    src = index;
                }
            });

            row.value.forEach(function (value) {
                var tar = 0;
                nodes.forEach(function (value1, index) {
                    if (value1.name === value) {
                        tar = index;
                    }
                });
                var link = {"source": src, "target": tar, "weight": 3};
                links.push(link);
            })
        });
        graphFile.nodes = nodes;
        graphFile.links = links;
        //console.log(graphFile);
        //var json = JSON.stringify(graphFile);
        //console.log("json => " + json);
    }

    var width = 1500,
        height = 1500;

    var svg = d3.select("body").append("svg")
        .attr("width", width)
        .attr("height", height);

    var force = d3.layout.force()
        .gravity(.04)
        .distance(700)
        .charge(-100)
        .size([width, height]);

    function draw() {
        force.nodes(graphFile.nodes).links(graphFile.links).start();

        var link = svg.selectAll(".link")
            .data(graphFile.links)
            .enter().append("line")
            .attr("class", "link")
            .style("stroke-width", function (d) {
                return Math.sqrt(d.weight);
            });

        var node = svg.selectAll(".node")
            .data(graphFile.nodes)
            .enter().append("g")
            .attr("class", "node")
            .call(force.drag);

        node.append("circle")
            .attr("r", "10")
            .attr("class", function (d, i) {
                return graphFile.nodes[i].name;
            });

        node.append("text")
            .attr("dx", 12)
            .attr("dy", ".35em")
            .text(function (d) {
                return d.name;
            });

        force.on("tick", function () {
            link.attr("x1", function (d) {
                return d.source.x;
            })
                .attr("y1", function (d) {
                    return d.source.y;
                })
                .attr("x2", function (d) {
                    return d.target.x;
                })
                .attr("y2", function (d) {
                    return d.target.y;
                });

            node.attr("transform", function (d) {
                return "translate(" + d.x + "," + d.y + ")";
            });
        });
        console.log("draw :: links => ", links);

        nodes.forEach(function (node) {
            var className = node.name.replace(/[.]/g, '\\\.');
            className = className.replace(/[:]/g, '\\\:');
            var curNode = $("." + className);
            links.forEach(function (link) {
                if (link.target.name === node.name) {
                    curNode.css('fill', '#7ce47a');
                }
            });

            appendBlockHeight(node.name, curNode);
        });
    }

    function appendBlockHeight(grpcUrl, curNode) {
        var url = getLatestBlockReqUrl(getRestUrl(grpcUrl), branchId);
        $.getJSON(url).done(function (data) {
            var blockHeight = data.index;
            if (blockHeight < 1 || blockHeight < curBlockHeight) {
                curNode.css("fill", "#d46979");
            } else {
                curNode.css("fill", "#7ce47a");
            }
            curNode.next().append("[" + blockHeight + "]");
        });
    }

    $("#drawNetwork").click(function () {
        submit(channels.pop());
        setTimeout(function () {
            arrangeTable();
            draw();
        }, 5000);
    });
</script>

</body>
</html>